name: Shai-Hulud Detection

on:
  schedule:
    - cron: "5 4 * * *"
  workflow_dispatch:

permissions:
  contents: read

jobs:
  shai-hulud-detect:
    runs-on: ubuntu-latest

    steps:
      # Downloads a copy of the code in your repository by default
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          ref: main
          path: project
          fetch-depth: 1

      # Checkout the security scanning repo we're using
      - name: Checkout scanner
        uses: actions/checkout@v6
        with:
          repository: Cobenian/shai-hulud-detect
          ref: main
          path: scanner
          fetch-depth: 1

      - name: Run scanner
        run: |
          chmod +x ./scanner/shai-hulud-detector.sh
          
          # Run scanner and capture output
          set +e
          ./scanner/shai-hulud-detector.sh ./project > scan_output.txt 2>&1
          scan_exit_code=$?
          set -e
          
          # Filter out ignored paths if .shai-hulud-ignore exists (repo root)
          if [ -f .shai-hulud-ignore ]; then
            echo "Filtering scan results based on .shai-hulud-ignore..."
            
            # Read ignore patterns and normalize them
            ignore_patterns=()
            while IFS= read -r pattern || [ -n "$pattern" ]; do
              # Skip comments and empty lines
              [[ "$pattern" =~ ^#.*$ || -z "$pattern" ]] && continue
              # Escape special regex characters and match with or without /project/ prefix
              escaped_pattern=$(echo "$pattern" | sed 's/[.\/*]/\\&/g')
              ignore_patterns+=("$escaped_pattern")
            done < .shai-hulud-ignore
            
            # Filter the output
            filtered_output=$(cat scan_output.txt)
            for pattern in "${ignore_patterns[@]}"; do
              # Remove lines containing the ignored path (with or without /project/ prefix)
              filtered_output=$(echo "$filtered_output" | grep -v "$pattern" || true)
            done
            
            # Recalculate summary based on remaining sections
            high_count=$(echo "$filtered_output" | grep -c "ðŸš¨ HIGH RISK:" || true)
            med_count=$(echo "$filtered_output" | grep -c "âš ï¸  MEDIUM RISK:" || true)
            crit_count=$(echo "$filtered_output" | grep -c "Total Critical Issues:" | awk '{print $4}' || echo 0)

            # Update summary lines if present
            filtered_output=$(echo "$filtered_output" | sed -E "s/(High Risk Issues: )([0-9]+)/\1$high_count/")
            filtered_output=$(echo "$filtered_output" | sed -E "s/(Medium Risk Issues: )([0-9]+)/\1$med_count/")

            echo "$filtered_output"
            # Exit code based on counts
            if [ "$high_count" -gt 0 ]; then
              exit 1
            elif [ "$med_count" -gt 0 ]; then
              exit 2
            else
              exit 0
            fi
          else
            # No ignore file, use original output and exit code
            cat scan_output.txt
            exit $scan_exit_code
          fi
