name: Shai-Hulud Detection

on:
  schedule:
    - cron: "5 4 * * *"
  workflow_dispatch:

permissions:
  contents: read

jobs:
  shai-hulud-detect:
    runs-on: ubuntu-latest

    steps:
      # Downloads a copy of the code in your repository by default
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          ref: main
          path: project
          fetch-depth: 1

      # Checkout the security scanning repo we're using
      - name: Checkout scanner
        uses: actions/checkout@v6
        with:
          repository: Cobenian/shai-hulud-detect
          ref: main
          path: scanner
          fetch-depth: 1

      - name: Run scanner
        run: |
          chmod +x ./scanner/shai-hulud-detector.sh
          
          # Run scanner and capture output
          set +e
          ./scanner/shai-hulud-detector.sh ./project > scan_output.txt 2>&1
          scan_exit_code=$?
          set -e
          
          # Filter out ignored paths if .shai-hulud-ignore exists (repo root)
          if [ -f .shai-hulud-ignore ]; then
            echo "Filtering scan results based on .shai-hulud-ignore..."
            
            # Read ignore patterns and normalize them
            ignore_patterns=()
            while IFS= read -r pattern || [ -n "$pattern" ]; do
              # Skip comments and empty lines
              [[ "$pattern" =~ ^#.*$ || -z "$pattern" ]] && continue
              # Build patterns that match absolute runner path prefixes
              # Example output line contains: .../project/<pattern>
              absolute_pattern="/project/$pattern"
              ignore_patterns+=("$pattern" "${absolute_pattern}")
            done < .shai-hulud-ignore
            
            # Build a single regex alternation from ignore patterns
            regex=$(printf "%s\n" "${ignore_patterns[@]}" | sed 's/[^^$.*+?{}()|[\]\\]/\\&/g' | paste -sd '|' -)

            # Remove entire risk blocks that reference ignored paths in 'Found in:' lines
            filtered_output=$(awk -v re="$regex" '
              BEGIN { RS="\n\n"; ORS="\n\n" }
              {
                # Drop block if it contains a Found in: line with a path matching re
                if ($0 ~ /Found in:/ && $0 ~ re) {
                  next;
                }
                print $0;
              }
            ' scan_output.txt)
            
            # Recalculate summary based on remaining sections
            high_count=$(echo "$filtered_output" | grep -c "HIGH RISK:" || true)
            med_count=$(echo "$filtered_output" | grep -c "MEDIUM RISK:" || true)
            # If summary lines exist, update them; otherwise append a summary

            # Update summary lines if present
            if echo "$filtered_output" | grep -q "High Risk Issues:"; then
              filtered_output=$(echo "$filtered_output" | sed -E "s/(High Risk Issues: )([0-9]+)/\1$high_count/")
              filtered_output=$(echo "$filtered_output" | sed -E "s/(Medium Risk Issues: )([0-9]+)/\1$med_count/")
            else
              filtered_output=$(printf "%s\n==============================================\nðŸ” SUMMARY:\n   High Risk Issues: %s\n   Medium Risk Issues: %s\n==============================================\n" "$filtered_output" "$high_count" "$med_count")
            fi

            echo "$filtered_output"
            # Exit code based on counts
            if [ "$high_count" -gt 0 ]; then
              exit 1
            elif [ "$med_count" -gt 0 ]; then
              exit 2
            else
              exit 0
            fi
          else
            # No ignore file, use original output and exit code
            cat scan_output.txt
            exit $scan_exit_code
          fi
